import{preview_federation as e}from"@fedimint/fedimint-client-wasm-bundler";const t=["debug","info","warn","error","none"];const i=new class{constructor(e="none"){this.level=e}setLevel(e){this.level=e}coerceLevel(e){return t.includes(e.toLocaleUpperCase())?e.toLocaleUpperCase():"info"}log(e,t,...i){const n=this.coerceLevel(e);if(!this.shouldLog(n))return;(0,console[n])(`[${n.toUpperCase()}] ${t}`,...i)}debug(e,...t){this.log("debug",e,...t)}info(e,...t){this.log("info",e,...t)}warn(e,...t){this.log("warn",e,...t)}error(e,...t){this.log("error",e,...t)}shouldLog(e){const t=["debug","info","warn","error","none"],i=t.indexOf(e);return t.indexOf(this.level)<=i&&"none"!==this.level&&"none"!==e}};class n{constructor(e){this.subscriptions=new Map,this.cancelRequest=e}addSubscription(e,t,i,n=()=>{}){const s=()=>{this.cancelSubscription(e)},r={id:e,onData:t,onError:i,onEnd:n,cancelFn:s};return this.subscriptions.set(e,r),s}handleResponse(e,t){const n=this.subscriptions.get(e);if(n)switch(t.type){case"data":n.onData(t.data);break;case"error":n.onError(t.error),this.removeSubscription(e);break;case"end":case"aborted":n.onEnd(),this.removeSubscription(e)}else i.warn("SubscriptionManager - handleResponse - received message with no subscription",e,t)}cancelSubscription(e){this.subscriptions.get(e)&&(this.cancelRequest(e),this.removeSubscription(e))}removeSubscription(e){this.subscriptions.delete(e)}cancelAll(){Array.from(this.subscriptions.keys()).forEach((e=>this.cancelSubscription(e)))}clear(){this.subscriptions.clear()}getActiveSubscriptionCount(){return this.subscriptions.size}getActiveSubscriptionIds(){return Array.from(this.subscriptions.keys())}}class s{constructor(e){this.requestCounter=0,this.handleWorkerMessage=e=>{this.subscriptionManager.handleResponse(e.request_id,e)},this.transportInit=e,this.subscriptionManager=new n(this.sendCancelRequest.bind(this))}sendCancelRequest(e){const t={request_id:++this.requestCounter,type:"cancel_rpc",cancel_request_id:e};this.transport?.sendRequest(t)}async initializeInner(){this.transport=await this.transportInit.init(this.handleWorkerMessage.bind(this))}async initialize(){return this.initPromise||(this.initPromise=this.initializeInner()),this.initPromise}async joinFederation(e,t){await this.internalRpcSingle({type:"join_federation",invite_code:e,client_name:t})}async openClient(e){await this.internalRpcSingle({type:"open_client",client_name:e}),this.clientName=e}async closeClient(e){await this.internalRpcSingle({type:"close_client",client_name:e}),this.clientName=void 0}internalRpcStream(e,t,n,s=()=>{}){const r=++this.requestCounter;i.debug("RpcClient - rpcStream",r,e);const a={...e,request_id:r},c=this.subscriptionManager.addSubscription(r,t,n,s);return this.transport?.sendRequest(a),c}internalRpcSingle(e){return new Promise(((t,i)=>{this.internalRpcStream(e,(e=>t(e)),(e=>i(new Error(e))),(()=>{}))}))}rpcStream(e,t,i,n,s,r=()=>{}){if(void 0===this.clientName)throw new Error("Wallet is not open");return this.internalRpcStream({type:"client_rpc",client_name:this.clientName,module:e,method:t,payload:i},n,s,r)}rpcSingle(e,t,i){if(void 0===this.clientName)throw new Error("Wallet is not open");return this.internalRpcSingle({type:"client_rpc",client_name:this.clientName,module:e,method:t,payload:i})}async cleanup(){this.subscriptionManager.cancelAll(),this.subscriptionManager.clear(),this.transport?.destroy(),this.requestCounter=0,this.initPromise=void 0}_getRequestCounter(){return this.requestCounter}_getActiveSubscriptionCount(){return this.subscriptionManager.getActiveSubscriptionCount()}_getActiveSubscriptionIds(){return this.subscriptionManager.getActiveSubscriptionIds()}}class r{constructor(e){this.worker=e}sendRequest(e){this.worker.postMessage(e)}destroy(){this.worker.terminate()}}class a{async init(e){const t=new Worker(new URL("./worker.js",import.meta.url),{type:"module"});return await new Promise(((e,n)=>{t.onmessage=t=>{const s=t.data;"init_error"===s.type?n(new Error(s.error)):"init_success"===s.type&&(i.info("WebWorker instantiated"),e())},t.postMessage({type:"init"})})),t.onmessage=t=>{e(t.data)},new r(t)}}class c{constructor(e){this.client=e}async redeemEcash(e){return await this.client.rpcSingle("mint","reissue_external_notes",{oob_notes:e,extra_meta:null})}async reissueExternalNotes(e,t={}){return await this.client.rpcSingle("mint","reissue_external_notes",{oob_notes:e,extra_meta:t})}subscribeReissueExternalNotes(e,t=()=>{},i=()=>{}){return this.client.rpcStream("mint","subscribe_reissue_external_notes",{operation_id:e},t,i)}async spendNotes(e,t=86400,i=!1,n={}){const s="number"==typeof t?{nanos:0,secs:t}:t,[r,a]=await this.client.rpcSingle("mint","spend_notes",{amount:e,try_cancel_after:s,include_invite:i,extra_meta:n});return{notes:a,operation_id:r}}async parseNotes(e){return await this.client.rpcSingle("mint","validate_notes",{oob_notes:e})}async tryCancelSpendNotes(e){await this.client.rpcSingle("mint","try_cancel_spend_notes",{operation_id:e})}subscribeSpendNotes(e,t=()=>{},i=()=>{}){return this.client.rpcStream("mint","subscribe_spend_notes",{operation_id:e},(e=>t(e)),i)}async awaitSpendOobRefund(e){return await this.client.rpcSingle("mint","await_spend_oob_refund",{operation_id:e})}async getNotesByDenomination(){return await this.client.rpcSingle("mint","note_counts_by_denomination",{})}}class o{constructor(e){this.client=e}async getBalance(){return await this.client.rpcSingle("","get_balance",{})}subscribeBalance(e=()=>{},t=()=>{}){return this.client.rpcStream("","subscribe_balance_changes",{},(t=>e(parseInt(t))),t)}}class l{constructor(e){this.client=e}async createInvoice(e,t,i,n,s){const r=n??await this._getDefaultGatewayInfo();return await this.client.rpcSingle("ln","create_bolt11_invoice",{amount:e,description:t,expiry_time:i??null,extra_meta:s??{},gateway:r})}async createInvoiceTweaked(e,t,i,n,s,r,a){const c=r??await this._getDefaultGatewayInfo();return await this.client.rpcSingle("ln","create_bolt11_invoice_for_user_tweaked",{amount:e,description:t,expiry_time:s??null,user_key:i,index:n,extra_meta:a??{},gateway:c})}async scanReceivesForTweaks(e,t,i){return await this.client.rpcSingle("ln","scan_receive_for_user_tweaked",{user_key:e,indices:t,extra_meta:i??{}})}async _getDefaultGatewayInfo(){await this.updateGatewayCache();const e=await this.listGateways();return e[0]?.info}async payInvoice(e,t,i){const n=t??await this._getDefaultGatewayInfo();return await this.client.rpcSingle("ln","pay_bolt11_invoice",{maybe_gateway:n,invoice:e,extra_meta:i??{}})}async payInvoiceSync(e,t=1e4,i,n){return new Promise((async(s,r)=>{const{contract_id:a,fee:c}=await this.payInvoice(e,i,n),o=this.subscribeLnPay(a,(e=>{"string"!=typeof e&&"success"in e?(clearTimeout(l),o(),s({success:!0,data:{feeMsats:c,preimage:e.success.preimage}})):"string"!=typeof e&&"unexpected_error"in e&&r(new Error(e.unexpected_error.error_message))})),l=setTimeout((()=>{o(),s({success:!1,error:"Payment timeout"})}),t)}))}subscribeLnClaim(e,t=()=>{},i=()=>{}){return this.client.rpcStream("ln","subscribe_ln_claim",{operation_id:e},t,i)}subscribeLnPay(e,t=()=>{},i=()=>{}){return this.client.rpcStream("ln","subscribe_ln_pay",{operation_id:e},t,i)}async waitForPay(e){return new Promise(((t,i)=>{let n;const s=setTimeout((()=>{t({success:!1,error:"Waiting for receive timeout"})}),15e3);n=this.subscribeLnPay(e,(e=>{"string"!=typeof e&&"success"in e&&(clearTimeout(s),n(),t({success:!0,data:{preimage:e.success.preimage}}))}),(e=>{clearTimeout(s),n(),i(e)}))}))}subscribeLnReceive(e,t=()=>{},i=()=>{}){return this.client.rpcStream("ln","subscribe_ln_receive",{operation_id:e},t,i)}async waitForReceive(e,t=15e3){return new Promise(((i,n)=>{let s;const r=setTimeout((()=>{n(new Error("Timeout waiting for receive"))}),t);s=this.subscribeLnReceive(e,(e=>{"claimed"===e&&(clearTimeout(r),s(),i(e))}),(e=>{clearTimeout(r),s(),n(e)}))}))}async getGateway(e=null,t=!1){return await this.client.rpcSingle("ln","get_gateway",{gateway_id:e,force_internal:t})}async listGateways(){return await this.client.rpcSingle("ln","list_gateways",{})}async updateGatewayCache(){return await this.client.rpcSingle("ln","update_gateway_cache",{})}}class u{constructor(e){this.client=e}async hasPendingRecoveries(){return await this.client.rpcSingle("","has_pending_recoveries",{})}async waitForAllRecoveries(){await this.client.rpcSingle("","wait_for_all_recoveries",{})}subscribeToRecoveryProgress(e,t){return this.client.rpcStream("","subscribe_to_recovery_progress",{},e,t)}}class p{constructor(e){this.client=e}async getConfig(){return await this.client.rpcSingle("","get_config",{})}async getFederationId(){return await this.client.rpcSingle("","get_federation_id",{})}async getInviteCode(e=0){return await this.client.rpcSingle("","get_invite_code",{peer:e})}async listOperations(){return await this.client.rpcSingle("","list_operations",{})}}class h{constructor(e){this.client=e}async getWalletSummary(){return await this.client.rpcSingle("wallet","get_wallet_summary",{})}}const _="fm-default";class d{constructor(e=!1){this._openPromise=void 0,this._resolveOpen=()=>{},this._isOpen=!1,this._openPromise=new Promise((e=>{this._resolveOpen=e})),this._client=new s(new a),this.mint=new c(this._client),this.lightning=new l(this._client),this.balance=new o(this._client),this.federation=new p(this._client),this.recovery=new u(this._client),this.wallet=new h(this._client),i.info("FedimintWallet instantiated"),e||this.initialize()}async initialize(){i.info("Initializing RpcClient"),await this._client.initialize(),i.info("RpcClient initialized")}async waitForOpen(){return this._isOpen?Promise.resolve():this._openPromise}async open(e=_){if(this._isOpen)return i.warn("Wallet is already open"),!0;await this.initialize();try{return await this._client.openClient(e),this._isOpen=!0,this._resolveOpen(),!0}catch(e){return i.error("Error opening client",e),!1}}async joinFederation(e,t=_){if(await this._client.initialize(),this._isOpen)throw new Error("The FedimintWallet is already open. You can only call `joinFederation` on closed clients.");try{return await this._client.joinFederation(e,t),this._isOpen=!0,this._resolveOpen(),!0}catch(e){return i.error("Error joining federation",e),!1}}async previewFederation(t){try{i.debug("Previewing federation with invite code:",t);const n=await e(t);return i.debug("Federation preview result:",n),n}catch(e){throw i.error("Error previewing federation:",e),new Error(`Failed to preview federation: ${e}`)}}async cleanup(){this._openPromise=void 0,this._isOpen=!1,await this._client.cleanup()}isOpen(){return this._isOpen}setLogLevel(e){i.setLevel(e),i.info(`Log level set to ${e}.`)}_getActiveSubscriptionIds(){return this._client._getActiveSubscriptionIds()}_getActiveSubscriptionCount(){return this._client._getActiveSubscriptionCount()}_getRequestCounter(){return this._client._getRequestCounter()}}export{d as FedimintWallet};
//# sourceMappingURL=index.js.map
