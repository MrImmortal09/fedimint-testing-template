type Alias<T> = T & {};
type Resolve<T> = T & unknown;
type Seconds = Alias<number>;
type Nanos = Alias<number>;
type Duration = {
    nanos: Nanos;
    secs: Seconds;
};
type MSats = Alias<number>;
type Sats = Alias<number>;
type JSONValue = string | number | boolean | null | {
    [key: string]: JSONValue;
} | JSONValue[];
type JSONObject = Record<string, JSONValue>;
type Result<T, U = string> = {
    success: true;
    data?: T;
} | {
    success: false;
    error: U;
};
//# sourceMappingURL=utils.d.ts.map

declare const MODULE_KINDS: readonly ["", "ln", "mint", "wallet"];
type ModuleKind = (typeof MODULE_KINDS)[number];
type FederationConfig = JSONObject;
type GatewayInfo = {
    gateway_id: string;
    api: string;
    node_pub_key: string;
    federation_index: number;
    route_hints: RouteHint[];
    fees: FeeToAmount;
};
type LightningGateway = {
    info: GatewayInfo;
    vetted: boolean;
    ttl: Duration;
};
type RouteHint = {};
type FeeToAmount = {};
type OutgoingLightningPayment = {
    payment_type: PayType;
    contract_id: string;
    fee: MSats;
};
type PayType = {
    lightning: string;
} | {
    internal: string;
};
type LnPayState = 'created' | 'canceled' | {
    funded: {
        block_height: number;
    };
} | {
    waiting_for_refund: {
        error_reason: string;
    };
} | 'awaiting_change' | {
    success: {
        preimage: string;
    };
} | {
    refunded: {
        gateway_error: string;
    };
} | {
    unexpected_error: {
        error_message: string;
    };
};
type LnReceiveState = 'created' | {
    waiting_for_payment: {
        invoice: string;
        timeout: number;
    };
} | {
    canceled: {
        reason: string;
    };
} | 'funded' | 'awaiting_funds' | 'claimed';
type CreateBolt11Response = {
    operation_id: string;
    invoice: string;
};
type StreamError = {
    error: string;
    data: never;
    end: never;
};
type StreamSuccess<T extends JSONValue> = {
    data: T;
    error: never;
    end: never;
};
type StreamEnd = {
    end: string;
    data: never;
    error: never;
};
type StreamResult<T extends JSONValue> = StreamSuccess<T> | StreamError | StreamEnd;
type CancelFunction = () => void;
type ReissueExternalNotesState = 'Created' | 'Issuing' | 'Done';
type MintSpendNotesResponse = Array<string>;
type SpendNotesState = 'Created' | 'UserCanceledProcessing' | 'UserCanceledSuccess' | 'UserCanceledFailure' | 'Success' | 'Refunded';
type TxOutputSummary = {
    outpoint: {
        txid: string;
        vout: number;
    };
    amount: number;
};
type WalletSummary = {
    spendable_utxos: TxOutputSummary[];
    unsigned_peg_out_txos: TxOutputSummary[];
    unsigned_change_utxos: TxOutputSummary[];
    unconfirmed_peg_out_txos: TxOutputSummary[];
    unconfirmed_change_utxos: TxOutputSummary[];
};
/** Keys are powers of 2 */
type NoteCountByDenomination = Record<number, number>;
//# sourceMappingURL=wallet.d.ts.map

type RpcRequestFull = {
    request_id: number;
} & RpcRequest;
type RpcRequest = {
    type: 'join_federation';
    invite_code: string;
    client_name: string;
} | {
    type: 'open_client';
    client_name: string;
} | {
    type: 'close_client';
    client_name: string;
} | {
    type: 'client_rpc';
    client_name: string;
    module: string;
    method: string;
    payload: any;
} | {
    type: 'cancel_rpc';
    cancel_request_id: number;
};
type RpcResponseFull = {
    request_id: number;
} & RpcResponse;
type RpcResponse = {
    type: 'data';
    data: any;
} | {
    type: 'error';
    error: string;
} | {
    type: 'aborted';
} | {
    type: 'end';
};

interface RpcTransport {
    sendRequest(request: RpcRequestFull): void;
    destroy(): void;
}
interface RpcTransportInit {
    init(onRpcResponse: (response: RpcResponseFull) => void): Promise<RpcTransport>;
}
declare class RpcClient {
    private transport?;
    private transportInit;
    private requestCounter;
    private requestCallbacks;
    private initPromise?;
    private clientName;
    constructor(transportInit: RpcTransportInit);
    private initializeInner;
    initialize(): Promise<void>;
    private handleWorkerMessage;
    joinFederation(inviteCode: string, clientName: string): Promise<void>;
    openClient(clientName: string): Promise<void>;
    closeClient(clientName: string): Promise<void>;
    private internalRpcStream;
    private internalRpcSingle;
    rpcStream<Response extends JSONValue = JSONValue, Body extends JSONValue = JSONValue>(module: ModuleKind, method: string, body: Body, onData: (data: Response) => void, onError: (error: string) => void, onEnd?: () => void): CancelFunction;
    rpcSingle<T extends JSONValue = JSONValue, P extends JSONValue = JSONValue>(module: string, method: string, payload: P): Promise<T>;
    cleanup(): Promise<void>;
    _getRequestCounter(): number;
    _getRequestCallbackMap(): Map<number, (response: RpcResponse) => void>;
}

declare class MintService {
    private client;
    constructor(client: RpcClient);
    /** https://web.fedimint.org/core/FedimintWallet/MintService/redeemEcash */
    redeemEcash(notes: string): Promise<string>;
    reissueExternalNotes(oobNotes: string, extraMeta?: JSONObject): Promise<string>;
    subscribeReissueExternalNotes(operationId: string, onSuccess?: (state: ReissueExternalNotesState) => void, onError?: (error: string) => void): CancelFunction;
    /** https://web.fedimint.org/core/FedimintWallet/MintService/spendNotes */
    spendNotes(amountMsats: number, tryCancelAfter?: number | Duration, // defaults to 1 day
    includeInvite?: boolean, extraMeta?: JSONValue): Promise<{
        notes: string;
        operation_id: string;
    }>;
    /** https://web.fedimint.org/core/FedimintWallet/MintService/parseEcash */
    parseNotes(oobNotes: string): Promise<number>;
    tryCancelSpendNotes(operationId: string): Promise<void>;
    subscribeSpendNotes(operationId: string, onSuccess?: (state: SpendNotesState) => void, onError?: (error: string) => void): CancelFunction;
    awaitSpendOobRefund(operationId: string): Promise<JSONValue>;
    getNotesByDenomination(): Promise<NoteCountByDenomination>;
}

/**
 * Balance Service
 *
 * The Balance Service provides methods to interact with the balance of a Fedimint wallet.
 */
declare class BalanceService {
    private client;
    constructor(client: RpcClient);
    /** https://web.fedimint.org/core/FedimintWallet/BalanceService/getBalance */
    getBalance(): Promise<number>;
    /** https://web.fedimint.org/core/FedimintWallet/BalanceService/subscribeBalance */
    subscribeBalance(onSuccess?: (balanceMsats: number) => void, onError?: (error: string) => void): CancelFunction;
}

declare class LightningService {
    private client;
    constructor(client: RpcClient);
    /** https://web.fedimint.org/core/FedimintWallet/LightningService/createInvoice#lightning-createinvoice */
    createInvoice(amountMsats: number, description: string, expiryTime?: number, // in seconds
    gatewayInfo?: GatewayInfo, extraMeta?: JSONObject): Promise<CreateBolt11Response>;
    createInvoiceTweaked(amountMsats: number, description: string, tweakKey: string, index: number, expiryTime?: number, // in seconds
    gatewayInfo?: GatewayInfo, extraMeta?: JSONObject): Promise<CreateBolt11Response>;
    scanReceivesForTweaks(tweakKey: string, indices: number[], extraMeta?: JSONObject): Promise<string[]>;
    private _getDefaultGatewayInfo;
    /** https://web.fedimint.org/core/FedimintWallet/LightningService/payInvoice#lightning-payinvoice-invoice-string */
    payInvoice(invoice: string, gatewayInfo?: GatewayInfo, extraMeta?: JSONObject): Promise<OutgoingLightningPayment>;
    /** https://web.fedimint.org/core/FedimintWallet/LightningService/payInvoice#lightning-payinvoicesync-invoice-string */
    payInvoiceSync(invoice: string, timeoutMs?: number, gatewayInfo?: GatewayInfo, extraMeta?: JSONObject): Promise<{
        success: false;
        error?: string;
    } | {
        success: true;
        data: {
            feeMsats: number;
            preimage: string;
        };
    }>;
    subscribeLnClaim(operationId: string, onSuccess?: (state: LnReceiveState) => void, onError?: (error: string) => void): CancelFunction;
    /** https://web.fedimint.org/core/FedimintWallet/LightningService/payInvoice#lightning-payinvoice-invoice-string */
    subscribeLnPay(operationId: string, onSuccess?: (state: LnPayState) => void, onError?: (error: string) => void): CancelFunction;
    /** https://web.fedimint.org/core/FedimintWallet/LightningService/payInvoice#lightning-payinvoice-invoice-string */
    waitForPay(operationId: string): Promise<{
        success: false;
        error?: string;
    } | {
        success: true;
        data: {
            preimage: string;
        };
    }>;
    /** https://web.fedimint.org/core/FedimintWallet/LightningService/createInvoice#lightning-createinvoice */
    subscribeLnReceive(operationId: string, onSuccess?: (state: LnReceiveState) => void, onError?: (error: string) => void): CancelFunction;
    /** https://web.fedimint.org/core/FedimintWallet/LightningService/createInvoice#lightning-createinvoice */
    waitForReceive(operationId: string, timeoutMs?: number): Promise<LnReceiveState>;
    getGateway(gatewayId?: string | null, forceInternal?: boolean): Promise<LightningGateway | null>;
    listGateways(): Promise<LightningGateway[]>;
    updateGatewayCache(): Promise<JSONValue>;
}

declare class RecoveryService {
    private client;
    constructor(client: RpcClient);
    hasPendingRecoveries(): Promise<boolean>;
    waitForAllRecoveries(): Promise<void>;
    subscribeToRecoveryProgress(onSuccess: (progress: {
        module_id: number;
        progress: JSONValue;
    }) => void, onError: (error: string) => void): CancelFunction;
}

declare class FederationService {
    private client;
    constructor(client: RpcClient);
    getConfig(): Promise<JSONValue>;
    getFederationId(): Promise<string>;
    getInviteCode(peer?: number): Promise<string | null>;
    listOperations(): Promise<JSONValue[]>;
}

declare const logLevels: readonly ["debug", "info", "warn", "error", "none"];
type LogLevel = (typeof logLevels)[number];

declare class FedimintWallet {
    private _client;
    balance: BalanceService;
    mint: MintService;
    lightning: LightningService;
    federation: FederationService;
    recovery: RecoveryService;
    private _openPromise;
    private _resolveOpen;
    private _isOpen;
    /**
     * Creates a new instance of FedimintWallet.
     *
     * This constructor initializes a FedimintWallet instance, which manages communication
     * with a Web Worker. The Web Worker is responsible for running WebAssembly code that
     * handles the core Fedimint Client operations.
     *
     * (default) When not in lazy mode, the constructor immediately initializes the
     * Web Worker and begins loading the WebAssembly module in the background. This
     * allows for faster subsequent operations but may increase initial load time.
     *
     * In lazy mode, the Web Worker and WebAssembly initialization are deferred until
     * the first operation that requires them, reducing initial overhead at the cost
     * of a slight delay on the first operation.
     *
     * @param {boolean} lazy - If true, delays Web Worker and WebAssembly initialization
     *                         until needed. Default is false.
     *
     * @example
     * // Create a wallet with immediate initialization
     * const wallet = new FedimintWallet();
     * wallet.open();
     *
     * // Create a wallet with lazy initialization
     * const lazyWallet = new FedimintWallet(true);
     * // Some time later...
     * lazyWallet.initialize();
     * lazyWallet.open();
     */
    constructor(lazy?: boolean);
    initialize(): Promise<void>;
    waitForOpen(): Promise<void>;
    open(clientName?: string): Promise<boolean>;
    joinFederation(inviteCode: string, clientName?: string): Promise<boolean>;
    /**
     * This should ONLY be called when UNLOADING the wallet client.
     * After this call, the FedimintWallet instance should be discarded.
     */
    cleanup(): Promise<void>;
    isOpen(): boolean;
    /**
     * Sets the log level for the library.
     * @param level The desired log level ('DEBUG', 'INFO', 'WARN', 'ERROR', 'NONE').
     */
    setLogLevel(level: LogLevel): void;
}

export { FedimintWallet };
export type { Alias, CancelFunction, CreateBolt11Response, Duration, FederationConfig, FeeToAmount, GatewayInfo, JSONObject, JSONValue, LightningGateway, LnPayState, LnReceiveState, MSats, MintSpendNotesResponse, ModuleKind, NoteCountByDenomination, OutgoingLightningPayment, PayType, ReissueExternalNotesState, Resolve, Result, RouteHint, RpcRequest, RpcRequestFull, RpcResponse, RpcResponseFull, Sats, SpendNotesState, StreamError, StreamResult, StreamSuccess, TxOutputSummary, WalletSummary };
